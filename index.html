<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PNG編集アプリ</title>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200&display=swap">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root {
            --bg: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --container-bg: #fff;
            --card-bg: #f5f5f5;
            --text: #333;
            --text-sub: #666;
            --text-muted: #888;
            --border: #ddd;
            --sidebar-bg: #f0f0f0;
            --item-bg: #fff;
            --item-hover: #e8e8e8;
            --input-bg: #fff;
            --drop-bg: #f8f9ff;
            --drop-hover: #eef1ff;
            --accent: #667eea;
            --accent-hover: #5a6fd6;
        }
        .dark {
            --bg: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            --container-bg: #1e1e2e;
            --card-bg: #2a2a3e;
            --text: #e0e0e0;
            --text-sub: #aaa;
            --text-muted: #777;
            --border: #444;
            --sidebar-bg: #252535;
            --item-bg: #2a2a3e;
            --item-hover: #3a3a4e;
            --input-bg: #2a2a3e;
            --drop-bg: #252535;
            --drop-hover: #2a2a3e;
        }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: var(--bg); min-height: 100vh; padding: 20px; }
        .app { display: flex; gap: 20px; max-width: 1200px; margin: 0 auto; }
        .main { flex: 1; min-width: 0; overflow: hidden; background: var(--container-bg); border-radius: 16px; padding: 25px; box-shadow: 0 20px 60px rgba(0,0,0,0.3); }
        .sidebar { width: 280px; background: var(--sidebar-bg); border-radius: 16px; padding: 15px; box-shadow: 0 10px 40px rgba(0,0,0,0.2); max-height: calc(100vh - 40px); display: flex; flex-direction: column; }
        .hidden { display: none; }
        .header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; }
        .header h1 { color: var(--text); font-size: 24px; }
        .theme-btn { background: var(--card-bg); border: none; padding: 8px 12px; border-radius: 8px; cursor: pointer; display: flex; align-items: center; }
        .theme-btn:hover { transform: scale(1.1); }
        .help-btn { background: var(--card-bg); border: none; padding: 8px 14px; border-radius: 8px; cursor: pointer; display: flex; align-items: center; gap: 4px; font-size: 13px; color: var(--text); font-weight: 600; }
        .help-btn:hover { background: var(--accent); color: #fff; }
        .help-panel { position: fixed; top: 0; right: 0; width: 320px; height: 100vh; background: var(--container-bg); box-shadow: -5px 0 30px rgba(0,0,0,0.3); z-index: 1000; transform: translateX(100%); transition: transform 0.3s ease; overflow-y: auto; }
        .help-panel.show { transform: translateX(0); }
        .help-panel-header { display: flex; justify-content: space-between; align-items: center; padding: 20px; border-bottom: 1px solid var(--border); position: sticky; top: 0; background: var(--container-bg); z-index: 1; }
        .help-panel-header h2 { color: var(--text); font-size: 16px; display: flex; align-items: center; gap: 8px; margin: 0; }
        .help-panel .close-btn { background: none; border: none; cursor: pointer; color: var(--text-muted); padding: 4px; border-radius: 4px; }
        .help-panel .close-btn:hover { background: var(--card-bg); color: var(--text); }
        .help-panel-content { padding: 20px; }
        .help-section { margin-bottom: 20px; }
        .help-section h3 { color: var(--accent); font-size: 13px; margin-bottom: 8px; display: flex; align-items: center; gap: 6px; }
        .help-section ul { list-style: none; padding-left: 0; margin: 0; }
        .help-section li { color: var(--text-sub); font-size: 12px; padding: 5px 0; padding-left: 16px; position: relative; line-height: 1.5; }
        .help-section li::before { content: '•'; position: absolute; left: 4px; color: var(--accent); }
        .help-section li b { color: var(--text); }
        .icon { font-family: 'Material Symbols Rounded'; font-size: 20px; vertical-align: middle; }
        .icon-sm { font-size: 16px; }
        .icon-lg { font-size: 24px; }
        .drop { border: 3px dashed var(--accent); border-radius: 12px; padding: 40px 20px; text-align: center; cursor: pointer; background: var(--drop-bg); margin-bottom: 20px; }
        .drop:hover, .drop.dragover { background: var(--drop-hover); border-color: #764ba2; }
        .drop p { color: var(--text-sub); font-size: 16px; }
        .drop input { display: none; }
        .tools { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 12px; margin-bottom: 15px; }
        .card { background: var(--card-bg); border-radius: 10px; padding: 12px; position: relative; padding-bottom: 45px; }
        .card .btn-apply { position: absolute; bottom: 10px; right: 10px; }
        .card h4 { margin-bottom: 8px; color: var(--text); font-size: 14px; }
        .row { display: flex; align-items: center; gap: 8px; margin-bottom: 6px; flex-wrap: wrap; }
        .row label { font-size: 12px; color: var(--text-sub); }
        .row span { color: var(--text-sub); }
        .tol-row { display: flex; align-items: center; gap: 6px; width: 100%; }
        .tol-row label { flex-shrink: 0; font-size: 11px; color: var(--text-sub); min-width: 32px; }
        .tol-row input[type="range"] { flex: 1; min-width: 60px; }
        .tol-row .val { min-width: 28px; text-align: right; font-size: 11px; color: var(--text-sub); flex-shrink: 0; }
        input[type="range"] { height: 5px; border-radius: 3px; background: var(--border); -webkit-appearance: none; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 14px; height: 14px; border-radius: 50%; background: var(--accent); cursor: pointer; }
        input[type="color"] { width: 32px; height: 26px; border: none; border-radius: 5px; cursor: pointer; }
        input[type="number"] { width: 65px; padding: 5px 7px; border: 2px solid var(--border); border-radius: 5px; font-size: 12px; background: var(--input-bg); color: var(--text); }
        input[type="checkbox"] { width: 16px; height: 16px; accent-color: var(--accent); }
        .canvas-area { display: block; margin-bottom: 15px; }
        .canvas-wrap { text-align: center; }
        .canvas-wrap.full { width: 100%; }
        .orig-section { margin-bottom: 15px; }
        .orig-section.hidden { display: none; }
        .toggle-orig { padding: 6px 14px; font-size: 12px; background: var(--card-bg); color: var(--text); border: 2px solid transparent; border-radius: 7px; cursor: pointer; margin-bottom: 10px; }
        .toggle-orig.active { border-color: var(--accent); background: var(--accent); color: #fff; }
        .canvas-wrap h3 { margin-bottom: 8px; color: var(--text); font-size: 14px; display: flex; align-items: center; justify-content: center; gap: 6px; }
        .canvas-container { position: relative; overflow: hidden; border: 1px solid var(--border); border-radius: 8px; background: repeating-conic-gradient(#ccc 0% 25%, #fff 0% 50%) 50% / 14px 14px; height: 450px; width: 100%; max-width: 100%; display: flex; align-items: center; justify-content: center; }
        .canvas-container canvas { display: block; transform-origin: center center; }
        .canvas-container.hand { cursor: grab; }
        .canvas-container.hand:active { cursor: grabbing; }
        .lasso-clear { position: absolute; bottom: 10px; right: 10px; padding: 6px 12px; font-size: 12px; background: rgba(255, 153, 0, 0.9); color: #fff; border: none; border-radius: 6px; cursor: pointer; z-index: 10; display: none; }
        .lasso-clear:hover { background: rgba(255, 120, 0, 1); }
        .zoom-row { display: flex; gap: 8px; align-items: center; justify-content: center; margin-top: 6px; }
        .zoom-row input[type="range"] { width: 60px; }
        .zoom-row span { font-size: 11px; color: var(--text-sub); min-width: 40px; }
        .zoom-row button { padding: 2px 6px; font-size: 11px; background: var(--card-bg); border: 1px solid var(--border); border-radius: 4px; cursor: pointer; color: var(--text); }
        .zoom-row button:hover { background: var(--item-hover); }
        #workCvs.pick { cursor: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24'%3E%3Ccircle cx='12' cy='12' r='10' fill='none' stroke='%23667eea' stroke-width='2'/%3E%3Ccircle cx='12' cy='12' r='3' fill='%23667eea'/%3E%3C/svg%3E") 12 12, crosshair; }
        #workCvs.crop, #workCvs.select, #workCvs.lasso { cursor: crosshair; }
        .info { text-align: center; color: var(--text-muted); font-size: 11px; margin-bottom: 10px; }
        .mode-btns { display: flex; gap: 8px; justify-content: center; margin-bottom: 10px; flex-wrap: wrap; }
        .mode-btn { padding: 6px 14px; font-size: 12px; background: var(--card-bg); color: var(--text); border: 2px solid transparent; border-radius: 7px; cursor: pointer; }
        .mode-btn.active { border-color: var(--accent); background: var(--accent); color: #fff; }
        .btns { display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; }
        button { padding: 9px 18px; font-size: 13px; border: none; border-radius: 7px; cursor: pointer; font-weight: 600; transition: all 0.2s; }
        .btn-apply { background: var(--accent); color: #fff; }
        .btn-apply:hover { background: var(--accent-hover); }
        .btn-reset { background: var(--card-bg); color: var(--text); }
        .btn-dl { background: linear-gradient(135deg, #11998e, #38ef7d); color: #fff; }
        .btn-dl:hover { transform: translateY(-2px); box-shadow: 0 5px 15px rgba(17,153,142,0.4); }
        .sidebar h4 { font-size: 13px; color: var(--text-sub); margin-bottom: 10px; padding-bottom: 8px; border-bottom: 1px solid var(--border); }
        .history { display: flex; flex-direction: column; gap: 6px; overflow-y: auto; flex: 1; }
        .history-item { display: flex; align-items: center; gap: 8px; background: var(--item-bg); padding: 8px 10px; border-radius: 6px; font-size: 11px; cursor: pointer; color: var(--text); }
        .history-item:hover { background: var(--item-hover); }
        .history-item.active { background: var(--accent); color: #fff; }
        .history-item.active .detail, .history-item.active .del { color: rgba(255,255,255,0.8); }
        .num { font-weight: bold; min-width: 18px; }
        .info-wrap { flex: 1; min-width: 0; }
        .label { font-weight: 600; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .detail { font-size: 10px; color: var(--text-muted); margin-top: 2px; }
        .del { background: none; border: none; color: var(--text-muted); cursor: pointer; padding: 3px 6px; border-radius: 4px; font-size: 12px; }
        .del:hover { background: #ff5252; color: #fff; }
        .del:disabled { opacity: 0.3; cursor: not-allowed; }
        @media (max-width: 900px) {
            .app { flex-direction: column; }
            .sidebar { width: 100%; max-height: 200px; }
        }
    </style>
</head>
<body>
    <div class="app">
        <div class="main">
            <div class="header">
                <h1><span class="icon icon-lg">image</span> PNG編集アプリ</h1>
                <div style="display: flex; gap: 8px; align-items: center;">
                    <button class="help-btn" id="helpBtn" title="使い方"><span class="icon icon-sm">info</span> 使い方</button>
                    <button class="theme-btn" id="theme" title="ダークモード切替"><span class="icon" id="themeIcon">dark_mode</span></button>
                </div>
            </div>
            <div class="drop" id="drop">
                <p><span class="icon">folder_open</span> 画像をドラッグ＆ドロップ / クリック / Ctrl+V</p>
                <input type="file" id="file" accept="image/*">
            </div>
            <div class="hidden" id="editor">
                <div class="tools">
                    <div class="card">
                        <h4><span class="icon icon-sm">blur_on</span> 透過</h4>
                        <div class="row"><label>色</label><input type="color" id="tColor" value="#ffffff"></div>
                        <div class="tol-row"><label>許容値</label><input type="range" id="tTol" min="0" max="255" value="30"><span class="val" id="tTolV">30</span></div>
                        <div class="row"><input type="checkbox" id="tAll"><label>選択範囲全体を透過</label></div>
                        <button class="btn-apply" id="applyT">適用</button>
                    </div>
                    <div class="card">
                        <h4><span class="icon icon-sm">palette</span> 色置換</h4>
                        <div class="row"><input type="color" id="rFrom" value="#000000"><span>→</span><input type="color" id="rTo" value="#ff0000"></div>
                        <div class="tol-row"><label>許容値</label><input type="range" id="rTol" min="0" max="255" value="30"><span class="val" id="rTolV">30</span></div>
                        <button class="btn-apply" id="applyR">適用</button>
                    </div>
                    <div class="card">
                        <h4><span class="icon icon-sm">format_color_fill</span> 塗りつぶし</h4>
                        <div class="row"><label>色</label><input type="color" id="fColor" value="#ff0000"></div>
                        <div class="row"><input type="checkbox" id="fOnly"><label>透明部分のみ</label></div>
                        <button class="btn-apply" id="applyF">適用</button>
                    </div>
                    
                </div>
                <div class="canvas-area">
                    <div class="canvas-wrap full">
                        <h3><span class="icon icon-sm">edit</span> 編集キャンバス</h3>
                        <div class="mode-btns">
                            <button class="mode-btn active" id="modePick"><span class="icon icon-sm">colorize</span> カラーピッカー</button>
                            <button class="mode-btn" id="modeCrop"><span class="icon icon-sm">crop</span> トリミング</button>
                            <button class="mode-btn" id="modeSelect"><span class="icon icon-sm">select_all</span> 矩形選択</button>
                            <button class="mode-btn" id="modeLasso"><span class="icon icon-sm">gesture</span> 投げ縄</button>
                            
                            <button class="mode-btn" id="modeHand"><span class="icon icon-sm">pan_tool</span> ハンド</button>
                        </div>
                        <p class="info" id="modeInfo"><span class="icon icon-sm">lightbulb</span> クリックで色を取得</p>
                        <div class="canvas-container" id="workContainer"><canvas id="workCvs"></canvas><button class="lasso-clear" id="lassoClear"><span class="icon icon-sm">close</span> クリア</button></div>
                        <div class="zoom-row">
                            <span class="icon icon-sm">zoom_out</span>
                            <input type="range" id="workZoom" min="10" max="400" value="100">
                            <span class="icon icon-sm">zoom_in</span>
                            <span id="workZoomVal">100%</span>
                            <button id="workFit">フィット</button>
                            <span style="font-size:10px;color:var(--text-muted)">スクロールでズーム</span>
                        </div>
                    </div>
                </div>
                <button class="toggle-orig" id="toggleOrig"><span class="icon icon-sm">photo_library</span> 元画像を表示</button>
                <div class="orig-section hidden" id="origSection">
                    <div class="canvas-wrap">
                        <h3><span class="icon icon-sm">photo_library</span> 元画像（固定）</h3>
                        <div class="canvas-container" id="origContainer"><canvas id="origCvs"></canvas></div>
                        <div class="zoom-row">
                            <span class="icon icon-sm">zoom_out</span>
                            <input type="range" id="origZoom" min="10" max="400" value="100">
                            <span class="icon icon-sm">zoom_in</span>
                            <span id="origZoomVal">100%</span>
                            <button id="origFit">フィット</button>
                            <span style="font-size:10px;color:var(--text-muted)">スクロールでズーム</span>
                        </div>
                    </div>
                </div>
                
            </div>
        </div>
        <div class="sidebar hidden" id="sidebar">
            <div style="margin-bottom: 12px;">
                <button class="btn-dl" id="dl" style="width: 100%;"><span class="icon icon-sm">download</span> PNGダウンロード</button>
            </div>
            <div class="card" style="margin-bottom: 12px;">
                <h4><span class="icon icon-sm">straighten</span> 出力サイズ</h4>
                <div class="row"><input type="number" id="outW" min="1" max="4096"><span>×</span><input type="number" id="outH" min="1" max="4096" readonly></div>
            </div>
            <h4><span class="icon icon-sm">history</span> 編集履歴</h4>
            <div class="history" id="hist"></div>
            <button class="btn-reset" id="reset" style="width: 100%; margin-top: 10px; background: #e0e0e0;"><span class="icon icon-sm">refresh</span> リセット</button>
        </div>
    </div>
    <div class="help-panel" id="helpPanel">
        <div class="help-panel-header">
            <h2><span class="icon icon-sm">help</span> 使い方</h2>
            <button class="close-btn" id="closeHelp"><span class="icon">close</span></button>
        </div>
        <div class="help-panel-content">
            <div class="help-section">
                <h3><span class="icon icon-sm">upload_file</span> 画像の読み込み</h3>
                <ul>
                    <li>ドロップゾーンに画像をドラッグ＆ドロップ</li>
                    <li>クリックしてファイルを選択</li>
                    <li>Ctrl+V でクリップボードから貼り付け</li>
                </ul>
            </div>
            <div class="help-section">
                <h3><span class="icon icon-sm">mouse</span> キャンバス操作モード</h3>
                <ul>
                    <li><b>カラーピッカー</b>: クリックした位置の色を取得</li>
                    <li><b>トリミング</b>: ドラッグで範囲を切り抜き（Shift: 正方形）</li>
                    <li><b>矩形選択</b>: ドラッグで編集範囲を限定</li>
                    <li><b>投げ縄</b>: クリックで頂点追加、3点以上で自動確定</li>
                    <li><b>ハンド</b>: ドラッグで画像を移動</li>
                </ul>
            </div>
            <div class="help-section">
                <h3><span class="icon icon-sm">edit</span> 編集ツール</h3>
                <ul>
                    <li><b>透過</b>: 指定した色を透明に（許容値で範囲調整）</li>
                    <li><b>色置換</b>: 色Aを色Bに置き換え</li>
                    <li><b>塗りつぶし</b>: 透明部分または不透明部分を塗りつぶし</li>
                </ul>
            </div>
            <div class="help-section">
                <h3><span class="icon icon-sm">zoom_in</span> ズーム操作</h3>
                <ul>
                    <li>スライダーでズーム調整（10%〜400%）</li>
                    <li>マウスホイールでカーソル位置を中心にズーム</li>
                    <li>「フィット」ボタンで画面に合わせる</li>
                </ul>
            </div>
            <div class="help-section">
                <h3><span class="icon icon-sm">history</span> 履歴機能</h3>
                <ul>
                    <li>編集操作は自動で履歴に保存</li>
                    <li>履歴をクリックで過去の状態に戻る</li>
                    <li>✕ボタンで履歴を削除（元画像以外）</li>
                </ul>
            </div>
        </div>
    </div>
    <script>
    (() => {
        const $ = id => document.getElementById(id);
        const el = {
            drop: $('drop'), file: $('file'), editor: $('editor'), sidebar: $('sidebar'),
            origCvs: $('origCvs'), workCvs: $('workCvs'), hist: $('hist'), theme: $('theme'),
            origContainer: $('origContainer'), workContainer: $('workContainer'),
            tColor: $('tColor'), tTol: $('tTol'), tTolV: $('tTolV'),
            rFrom: $('rFrom'), rTo: $('rTo'), rTol: $('rTol'), rTolV: $('rTolV'),
            fColor: $('fColor'), fOnly: $('fOnly'),
            outW: $('outW'), outH: $('outH'),
            modePick: $('modePick'), modeCrop: $('modeCrop'), modeSelect: $('modeSelect'), modeLasso: $('modeLasso'), modeHand: $('modeHand'), modeInfo: $('modeInfo'),
            tAll: $('tAll'),
            origZoom: $('origZoom'), origZoomVal: $('origZoomVal'),
            workZoom: $('workZoom'), workZoomVal: $('workZoomVal')
        };
        const origCtx = el.origCvs.getContext('2d');
        const workCtx = el.workCvs.getContext('2d');

        let origImg = null, history = [], idx = -1, ratio = 1;
        let crop = { start: null, end: null, active: false, shift: false };
        let mode = 'pick';
        let selection = null;
        let lassoPoints = [];
        let lassoActive = false;
        let dark = localStorage.getItem('dark') === '1';
        let zoomOrig = 100, zoomWork = 100;
        let panOrig = { x: 0, y: 0 }, panWork = { x: 0, y: 0 };
        let dragging = null;

        // Theme
        const setTheme = () => {
            document.body.classList.toggle('dark', dark);
            $('themeIcon').textContent = dark ? 'light_mode' : 'dark_mode';
            localStorage.setItem('dark', dark ? '1' : '0');
        };
        setTheme();
        el.theme.onclick = () => { dark = !dark; setTheme(); };
        // Help side panel
        const helpPanel = $('helpPanel');
        $('helpBtn').onclick = () => helpPanel.classList.toggle('show');
        $('closeHelp').onclick = () => helpPanel.classList.remove('show');
        // Toggle original image
        const origSection = $('origSection');
        const toggleOrig = $('toggleOrig');
        let showOrig = false;
        toggleOrig.onclick = () => {
            showOrig = !showOrig;
            origSection.classList.toggle('hidden', !showOrig);
            toggleOrig.classList.toggle('active', showOrig);
            toggleOrig.innerHTML = showOrig 
                ? '<span class="icon icon-sm">photo_library</span> 元画像を非表示' 
                : '<span class="icon icon-sm">photo_library</span> 元画像を表示';
            if (showOrig) setTimeout(fitOrigZoom, 50);
        };

        // Utils
        const hex2rgb = hex => {
            const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return { r: parseInt(m[1],16), g: parseInt(m[2],16), b: parseInt(m[3],16) };
        };
        const colorDist = (d, i, c) => Math.sqrt((d[i]-c.r)**2 + (d[i+1]-c.g)**2 + (d[i+2]-c.b)**2);
        const getCoords = (e, cvs, z, pan) => {
            const r = cvs.getBoundingClientRect();
            const scale = z / 100;
            const containerW = cvs.parentElement.clientWidth;
            const containerH = cvs.parentElement.clientHeight;
            const offsetX = (containerW - cvs.width * scale) / 2 + pan.x;
            const offsetY = (containerH - cvs.height * scale) / 2 + pan.y;
            return { 
                x: (e.clientX - r.left + cvs.parentElement.scrollLeft - offsetX + (cvs.width * scale - cvs.offsetWidth) / 2) / scale, 
                y: (e.clientY - r.top + cvs.parentElement.scrollTop - offsetY + (cvs.height * scale - cvs.offsetHeight) / 2) / scale 
            };
        };

        // Zoom functions with center pivot
        const applyOrigZoom = () => {
            const s = zoomOrig / 100;
            el.origCvs.style.transform = `scale(${s}) translate(${panOrig.x / s}px, ${panOrig.y / s}px)`;
            el.origZoomVal.textContent = zoomOrig + '%';
            el.origZoom.value = zoomOrig;
        };
        const applyWorkZoom = () => {
            const s = zoomWork / 100;
            el.workCvs.style.transform = `scale(${s}) translate(${panWork.x / s}px, ${panWork.y / s}px)`;
            el.workZoomVal.textContent = zoomWork + '%';
            el.workZoom.value = zoomWork;
        };
        const fitOrigZoom = () => {
            const cw = el.origContainer.clientWidth - 20;
            const ch = el.origContainer.clientHeight - 20;
            zoomOrig = Math.max(10, Math.round(Math.min(cw / el.origCvs.width, ch / el.origCvs.height) * 100));
            panOrig = { x: 0, y: 0 };
            applyOrigZoom();
        };
        const fitWorkZoom = () => {
            const cw = el.workContainer.clientWidth - 20;
            const ch = el.workContainer.clientHeight - 20;
            zoomWork = Math.max(10, Math.round(Math.min(cw / el.workCvs.width, ch / el.workCvs.height) * 100));
            panWork = { x: 0, y: 0 };
            applyWorkZoom();
        };

        el.origZoom.oninput = () => { zoomOrig = +el.origZoom.value; applyOrigZoom(); };
        el.workZoom.oninput = () => { zoomWork = +el.workZoom.value; applyWorkZoom(); };
        $('origFit').onclick = fitOrigZoom;
        $('workFit').onclick = fitWorkZoom;

        // Mouse wheel zoom (Ctrl + scroll, zoom toward cursor)
        const wheelZoomOrig = e => {
            e.preventDefault();
            const rect = el.origContainer.getBoundingClientRect();
            const mx = e.clientX - rect.left - rect.width / 2;
            const my = e.clientY - rect.top - rect.height / 2;
            const oldZoom = zoomOrig;
            const delta = e.deltaY < 0 ? 10 : -10;
            zoomOrig = Math.max(10, Math.min(400, zoomOrig + delta));
            const ratio = zoomOrig / oldZoom;
            panOrig.x = mx - (mx - panOrig.x) * ratio;
            panOrig.y = my - (my - panOrig.y) * ratio;
            applyOrigZoom();
        };
        const wheelZoomWork = e => {
            e.preventDefault();
            const rect = el.workContainer.getBoundingClientRect();
            const mx = e.clientX - rect.left - rect.width / 2;
            const my = e.clientY - rect.top - rect.height / 2;
            const oldZoom = zoomWork;
            const delta = e.deltaY < 0 ? 10 : -10;
            zoomWork = Math.max(10, Math.min(400, zoomWork + delta));
            const ratio = zoomWork / oldZoom;
            panWork.x = mx - (mx - panWork.x) * ratio;
            panWork.y = my - (my - panWork.y) * ratio;
            applyWorkZoom();
        };
        el.origContainer.onwheel = wheelZoomOrig;
        el.workContainer.onwheel = wheelZoomWork;

        // Hand tool (pan)
        const setupPan = (container, cvs, getPan, setPan, applyZoom) => {
            let startMouse = null, startPan = null;
            container.onmousedown = e => {
                if (mode !== 'hand' && container !== el.origContainer) return;
                if (container === el.origContainer || mode === 'hand') {
                    startMouse = { x: e.clientX, y: e.clientY };
                    startPan = { ...getPan() };
                    dragging = container;
                    e.preventDefault();
                }
            };
            document.addEventListener('mousemove', e => {
                if (dragging !== container || !startMouse) return;
                const dx = e.clientX - startMouse.x;
                const dy = e.clientY - startMouse.y;
                setPan({ x: startPan.x + dx, y: startPan.y + dy });
                applyZoom();
            });
            document.addEventListener('mouseup', () => {
                if (dragging === container) { dragging = null; startMouse = null; }
            });
        };
        setupPan(el.origContainer, el.origCvs, () => panOrig, v => panOrig = v, applyOrigZoom);

        // History
        const save = (label, detail = '') => {
            const state = workCtx.getImageData(0, 0, el.workCvs.width, el.workCvs.height);
            history = history.slice(0, idx + 1);
            history.push({ data: state, label, detail, w: el.workCvs.width, h: el.workCvs.height, time: new Date().toLocaleTimeString() });
            idx = history.length - 1;
            renderHist();
        };

        const goTo = i => {
            if (i < 0 || i >= history.length) return;
            idx = i;
            const s = history[i];
            el.workCvs.width = s.w; el.workCvs.height = s.h;
            workCtx.putImageData(s.data, 0, 0);
            ratio = s.w / s.h;
            el.outW.value = s.w; el.outH.value = s.h;
            fitWorkZoom();
            renderHist();
        };

        const delState = i => {
            if (i === 0 || history.length <= 1) return;
            history.splice(i, 1);
            if (idx >= i) idx = Math.max(0, idx - 1);
            goTo(idx);
        };

        const renderHist = () => {
            el.hist.innerHTML = history.map((h, i) => `
                <div class="history-item ${i === idx ? 'active' : ''}" data-i="${i}">
                    <span class="num">${i + 1}</span>
                    <div class="info-wrap">
                        <div class="label">${h.label}</div>
                        <div class="detail">${h.detail} (${h.w}×${h.h}) ${h.time}</div>
                    </div>
                    <button class="del" data-i="${i}" ${i === 0 ? 'disabled' : ''}>✕</button>
                </div>
            `).join('');
            el.hist.querySelectorAll('.history-item').forEach(item => {
                item.onclick = e => { if (!e.target.classList.contains('del')) goTo(+item.dataset.i); };
            });
            el.hist.querySelectorAll('.del').forEach(btn => {
                btn.onclick = e => { e.stopPropagation(); delState(+btn.dataset.i); };
            });
        };

        // File Load
        const load = file => {
            if (!file?.type.startsWith('image/')) return;
            const reader = new FileReader();
            reader.onload = e => {
                const img = new Image();
                img.onload = () => { origImg = img; init(img); };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        };

        const init = img => {
            el.origCvs.width = img.width;
            el.origCvs.height = img.height;
            origCtx.drawImage(img, 0, 0);
            
            el.workCvs.width = img.width;
            el.workCvs.height = img.height;
            workCtx.drawImage(img, 0, 0);
            
            ratio = img.width / img.height;
            el.outW.value = img.width; el.outH.value = img.height;
            history = []; idx = -1;
            selection = null;
            panOrig = { x: 0, y: 0 }; panWork = { x: 0, y: 0 };
            
            // 初期状態でフィット
            fitOrigZoom();
            fitWorkZoom();
            
            save('元画像', '読み込み');
            el.editor.classList.remove('hidden');
            el.sidebar.classList.remove('hidden');
            setTimeout(() => { fitOrigZoom(); fitWorkZoom(); }, 50);
        };

        // Drop Zone
        el.drop.ondragover = e => { e.preventDefault(); el.drop.classList.add('dragover'); };
        el.drop.ondragleave = () => el.drop.classList.remove('dragover');
        el.drop.ondrop = e => { e.preventDefault(); el.drop.classList.remove('dragover'); load(e.dataTransfer.files[0]); };
        el.drop.onclick = () => el.file.click();
        el.file.onchange = e => load(e.target.files[0]);
        document.onpaste = e => { for (const item of e.clipboardData.items) if (item.type.startsWith('image/')) { load(item.getAsFile()); break; } };

        // Mode Switch
        const redrawWork = () => {
            if (idx < 0) return;
            workCtx.putImageData(history[idx].data, 0, 0);
            // 矩形選択の描画
            if (selection && selection.type !== 'lasso') {
                workCtx.strokeStyle = '#00cc66'; workCtx.lineWidth = 2; workCtx.setLineDash([6, 3]);
                workCtx.strokeRect(selection.x, selection.y, selection.w, selection.h);
                workCtx.setLineDash([]);
                workCtx.fillStyle = 'rgba(0, 204, 102, 0.15)';
                workCtx.fillRect(selection.x, selection.y, selection.w, selection.h);
            }
            // 投げ縄選択の描画（確定済み）
            if (selection && selection.type === 'lasso' && selection.points) {
                const pts = selection.points;
                workCtx.strokeStyle = '#ff9900'; workCtx.lineWidth = 2; workCtx.setLineDash([6, 3]);
                workCtx.beginPath();
                workCtx.moveTo(pts[0].x, pts[0].y);
                for (let i = 1; i < pts.length; i++) workCtx.lineTo(pts[i].x, pts[i].y);
                workCtx.closePath();
                workCtx.fillStyle = 'rgba(255, 153, 0, 0.15)';
                workCtx.fill();
                workCtx.stroke();
                workCtx.setLineDash([]);
            }
            // 投げ縄の描画中（未確定）
            if (lassoPoints.length > 0 && (!selection || selection.type !== 'lasso')) {
                workCtx.strokeStyle = '#ff9900'; workCtx.lineWidth = 2; workCtx.setLineDash([6, 3]);
                workCtx.beginPath();
                workCtx.moveTo(lassoPoints[0].x, lassoPoints[0].y);
                for (let i = 1; i < lassoPoints.length; i++) workCtx.lineTo(lassoPoints[i].x, lassoPoints[i].y);
                if (lassoPoints.length > 2) { workCtx.closePath(); workCtx.fillStyle = 'rgba(255, 153, 0, 0.15)'; workCtx.fill(); }
                workCtx.stroke();
                workCtx.setLineDash([]);
                lassoPoints.forEach((p, i) => {
                    workCtx.beginPath(); workCtx.arc(p.x, p.y, 4, 0, Math.PI * 2);
                    workCtx.fillStyle = i === 0 ? '#ff5500' : '#ff9900'; workCtx.fill();
                });
            }
        };

        const lassoClearBtn = $('lassoClear');
        const setMode = m => {
            mode = m;
            el.modePick.classList.toggle('active', m === 'pick');
            el.modeCrop.classList.toggle('active', m === 'crop');
            el.modeSelect.classList.toggle('active', m === 'select');
            el.modeLasso.classList.toggle('active', m === 'lasso');
            el.modeHand.classList.toggle('active', m === 'hand');
            lassoClearBtn.style.display = m === 'lasso' ? 'block' : 'none';
            el.workCvs.className = m;
            el.workContainer.classList.toggle('hand', m === 'hand');
            el.origContainer.classList.add('hand');
            const info = { 
                pick: '<span class="icon icon-sm">lightbulb</span> クリックで色を取得', 
                crop: '<span class="icon icon-sm">lightbulb</span> ドラッグでトリミング（Shift: 正方形）', 
                select: '<span class="icon icon-sm">lightbulb</span> ドラッグで矩形選択',
                lasso: '<span class="icon icon-sm">lightbulb</span> クリックで頂点追加（3点以上で自動確定）',
                hand: '<span class="icon icon-sm">lightbulb</span> ドラッグで画像を移動'
            };
            el.modeInfo.innerHTML = info[m];
            if (m !== 'select' && m !== 'lasso') { selection = null; lassoPoints = []; redrawWork(); }
        };
        lassoClearBtn.onclick = () => {
            lassoPoints = [];
            selection = null;
            redrawWork();
        };
        el.modePick.onclick = () => setMode('pick');
        el.modeCrop.onclick = () => setMode('crop');
        el.modeSelect.onclick = () => setMode('select');
        el.modeLasso.onclick = () => setMode('lasso');
        el.modeHand.onclick = () => setMode('hand');
        setMode('pick');

        // Work canvas interactions
        let workDragging = false, workStartMouse = null, workStartPan = null;
        
        el.workCvs.onmousedown = e => {
            if (mode === 'hand') {
                workDragging = true;
                workStartMouse = { x: e.clientX, y: e.clientY };
                workStartPan = { ...panWork };
                e.preventDefault();
            } else if (mode === 'crop' || mode === 'select') { 
                const rect = el.workCvs.getBoundingClientRect();
                const scale = zoomWork / 100;
                crop.start = {
                    x: (e.clientX - rect.left) / scale,
                    y: (e.clientY - rect.top) / scale
                };
                crop.active = true; 
                crop.shift = e.shiftKey; 
            }
        };
        
        document.addEventListener('mousemove', e => {
            if (workDragging && workStartMouse) {
                const dx = e.clientX - workStartMouse.x;
                const dy = e.clientY - workStartMouse.y;
                panWork = { x: workStartPan.x + dx, y: workStartPan.y + dy };
                applyWorkZoom();
            }
        });
        
        document.addEventListener('mouseup', () => {
            workDragging = false;
            workStartMouse = null;
        });

        el.workCvs.onmousemove = e => {
            if ((mode !== 'crop' && mode !== 'select') || !crop.active) return;
            crop.shift = e.shiftKey;
            const rect = el.workCvs.getBoundingClientRect();
            const scale = zoomWork / 100;
            let end = {
                x: (e.clientX - rect.left) / scale,
                y: (e.clientY - rect.top) / scale
            };
            if (crop.shift) {
                const dx = end.x - crop.start.x, dy = end.y - crop.start.y;
                const size = Math.max(Math.abs(dx), Math.abs(dy));
                end.x = crop.start.x + size * Math.sign(dx);
                end.y = crop.start.y + size * Math.sign(dy);
            }
            crop.end = end;
            workCtx.putImageData(history[idx].data, 0, 0);
            workCtx.strokeStyle = mode === 'crop' ? '#ff4444' : '#00cc66'; 
            workCtx.lineWidth = 3; 
            workCtx.setLineDash([10, 5]);
            workCtx.shadowColor = '#000'; 
            workCtx.shadowBlur = 2;
            workCtx.strokeRect(crop.start.x, crop.start.y, crop.end.x - crop.start.x, crop.end.y - crop.start.y);
        };
        
        el.workCvs.onmouseup = () => {
            if (crop.active && crop.end && Math.abs(crop.end.x - crop.start.x) > 10 && Math.abs(crop.end.y - crop.start.y) > 10) {
                const x = Math.round(Math.min(crop.start.x, crop.end.x));
                const y = Math.round(Math.min(crop.start.y, crop.end.y));
                const w = Math.round(Math.abs(crop.end.x - crop.start.x));
                const h = Math.round(Math.abs(crop.end.y - crop.start.y));
                if (mode === 'crop') {
                    const data = history[idx].data;
                    const srcW = history[idx].w;
                    const newData = new ImageData(w, h);
                    for (let py = 0; py < h; py++) {
                        for (let px = 0; px < w; px++) {
                            const srcIdx = ((y + py) * srcW + (x + px)) * 4;
                            const dstIdx = (py * w + px) * 4;
                            newData.data[dstIdx] = data.data[srcIdx];
                            newData.data[dstIdx + 1] = data.data[srcIdx + 1];
                            newData.data[dstIdx + 2] = data.data[srcIdx + 2];
                            newData.data[dstIdx + 3] = data.data[srcIdx + 3];
                        }
                    }
                    el.workCvs.width = w; el.workCvs.height = h;
                    workCtx.putImageData(newData, 0, 0);
                    ratio = w / h;
                    el.outW.value = w; el.outH.value = h;
                    panWork = { x: 0, y: 0 };
                    fitWorkZoom();
                    save('トリミング', `(${x},${y})→${w}×${h}`);
                } else if (mode === 'select') {
                    selection = { x, y, w, h };
                    workCtx.putImageData(history[idx].data, 0, 0);
                    workCtx.strokeStyle = '#00cc66'; workCtx.lineWidth = 2; workCtx.setLineDash([6, 3]);
                    workCtx.strokeRect(selection.x, selection.y, selection.w, selection.h);
                    workCtx.setLineDash([]);
                    workCtx.fillStyle = 'rgba(0, 204, 102, 0.15)';
                    workCtx.fillRect(selection.x, selection.y, selection.w, selection.h);
                }
            } else {
                // ドラッグキャンセル時は元に戻す
                if (idx >= 0) workCtx.putImageData(history[idx].data, 0, 0);
            }
            crop = { start: null, end: null, active: false };
        };

        let lastClickTime = 0;
        el.workCvs.onclick = e => {
            const now = Date.now();
            const rect = el.workCvs.getBoundingClientRect();
            const scale = zoomWork / 100;
            const x = Math.floor((e.clientX - rect.left) / scale);
            const y = Math.floor((e.clientY - rect.top) / scale);
            if (mode === 'pick') {
                const p = workCtx.getImageData(x, y, 1, 1).data;
                const hex = '#' + [p[0], p[1], p[2]].map(v => v.toString(16).padStart(2, '0')).join('');
                el.tColor.value = hex;
                el.rFrom.value = hex;
            } else if (mode === 'lasso') {
                // 点を追加（3点以上なら自動確定）
                lassoPoints.push({ x, y });
                if (lassoPoints.length >= 3) {
                    selection = { type: 'lasso', points: [...lassoPoints] };
                } else {
                    selection = null;
                }
                redrawWork();
            }
            lastClickTime = now;
        };

        // Tool Controls
        el.tTol.oninput = () => el.tTolV.textContent = el.tTol.value;
        el.rTol.oninput = () => el.rTolV.textContent = el.rTol.value;
        el.outW.oninput = () => el.outH.value = Math.round((+el.outW.value || 1) / ratio);

        // Apply Tools
        const pointInPolygon = (px, py, pts) => {
            let inside = false;
            for (let i = 0, j = pts.length - 1; i < pts.length; j = i++) {
                const xi = pts[i].x, yi = pts[i].y, xj = pts[j].x, yj = pts[j].y;
                if ((yi > py) !== (yj > py) && px < (xj - xi) * (py - yi) / (yj - yi) + xi) inside = !inside;
            }
            return inside;
        };
        const inSelection = (px, py) => {
            if (!selection) return true;
            if (selection.type === 'lasso') return pointInPolygon(px, py, selection.points);
            return px >= selection.x && px < selection.x + selection.w && py >= selection.y && py < selection.y + selection.h;
        };

        $('applyT').onclick = () => {
            const c = hex2rgb(el.tColor.value), tol = +el.tTol.value, all = el.tAll.checked;
            // 履歴データから取得（選択範囲の描画を含まない）
            const img = new ImageData(
                new Uint8ClampedArray(history[idx].data.data),
                history[idx].w,
                history[idx].h
            );
            const imgW = el.workCvs.width;
            let cnt = 0;
            for (let i = 0; i < img.data.length; i += 4) {
                const px = (i / 4) % imgW, py = Math.floor((i / 4) / imgW);
                if (inSelection(px, py)) {
                    if (all || colorDist(img.data, i, c) <= tol) { img.data[i+3] = 0; cnt++; }
                }
            }
            workCtx.putImageData(img, 0, 0);
            const selInfo = selection ? (selection.type === 'lasso' ? ' [投げ縄]' : ' [矩形]') : '';
            const modeInfo = all ? '全体' : `${el.tColor.value} 許容${tol}`;
            selection = null; lassoPoints = [];
            save('透過', `${modeInfo} → ${cnt}px${selInfo}`);
        };

        $('applyR').onclick = () => {
            const fc = hex2rgb(el.rFrom.value), tc = hex2rgb(el.rTo.value), tol = +el.rTol.value;
            // 履歴データから取得（選択範囲の描画を含まない）
            const img = new ImageData(
                new Uint8ClampedArray(history[idx].data.data),
                history[idx].w,
                history[idx].h
            );
            const imgW = el.workCvs.width;
            let cnt = 0;
            for (let i = 0; i < img.data.length; i += 4) {
                const px = (i / 4) % imgW, py = Math.floor((i / 4) / imgW);
                if (inSelection(px, py) && img.data[i+3] > 0 && colorDist(img.data, i, fc) <= tol) {
                    img.data[i] = tc.r; img.data[i+1] = tc.g; img.data[i+2] = tc.b; cnt++;
                }
            }
            workCtx.putImageData(img, 0, 0);
            const selInfo = selection ? ` [選択範囲]` : '';
            selection = null; lassoPoints = [];
            save('色置換', `${el.rFrom.value}→${el.rTo.value} → ${cnt}px${selInfo}`);
        };

        $('applyF').onclick = () => {
            const c = hex2rgb(el.fColor.value), only = el.fOnly.checked;
            // 履歴データから取得（選択範囲の描画を含まない）
            const img = new ImageData(
                new Uint8ClampedArray(history[idx].data.data),
                history[idx].w,
                history[idx].h
            );
            const imgW = el.workCvs.width;
            let cnt = 0;
            for (let i = 0; i < img.data.length; i += 4) {
                const px = (i / 4) % imgW, py = Math.floor((i / 4) / imgW);
                if (inSelection(px, py) && (only ? img.data[i+3] === 0 : img.data[i+3] > 0)) {
                    img.data[i] = c.r; img.data[i+1] = c.g; img.data[i+2] = c.b;
                    if (only) img.data[i+3] = 255;
                    cnt++;
                }
            }
            workCtx.putImageData(img, 0, 0);
            const selInfo = selection ? ` [選択範囲]` : '';
            selection = null; lassoPoints = [];
            save('塗りつぶし', `${el.fColor.value} ${only ? '透明のみ' : '不透明'} → ${cnt}px${selInfo}`);
        };

        // Reset & Download
        $('reset').onclick = () => { if (origImg) init(origImg); };
        $('dl').onclick = () => {
            const w = +el.outW.value, h = +el.outH.value;
            const cvs = document.createElement('canvas');
            cvs.width = w; cvs.height = h;
            cvs.getContext('2d').drawImage(el.workCvs, 0, 0, w, h);
            const a = document.createElement('a');
            a.download = 'edited.png';
            a.href = cvs.toDataURL('image/png');
            a.click();
        };
    })();
    </script>
</body>
</html>
